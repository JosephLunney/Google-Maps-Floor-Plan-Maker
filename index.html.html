<!--BUG FIXES
1. When two halls have a bearing of 0, the overlap test fails

-->
<!--
Floor Plan Maker
Jan 5th 2020
Joseph Lunney 
17jal21@queensu.ca 

I am currently looking for a summer job and greatly appreciate you checking out my newest project!

I reccomend you check out the intializeFloorGraph function and the DijkstrasAlgorithm function.

-->


<!DOCTYPE html>
<html>
  <head>
    <title>Floor Plan Maker</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
      
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
        width:70% ; 
        text-align: left ;
        float:left ; 
      }

      #palette {
        width:30%;
        height: 90% ;
        text-align: right ;  
        background-color:red ;
        align-self: right ; 
        float: left ; 
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 90%;
        margin: 0;
        padding: 0;
      }

      #header {
        height: 10% ; 
        width: 100% ;
        background-color: green ;  
      }

      #saveButton {
        height: 10% ; 
        width: 25% ; 
        background-color: purple ; 
        align-self: left ;
        float: left ;
      }

      #loadButton {
        height: 10% ; 
        width: 25% ; 
        background-color: yellow ; 
        align-self: left ;
        float: left ;  
      }

      #newMapItem {
        height: 10% ; 
        width: 25% ; 
        background-color: pink ; 
        align-self: left ;
        float: left ;  
      }

      #removeHallButton {
        height: 10% ; 
        width: 25% ; 
        background-color: orange ;  
        align-self: left ; 
        float: left ; 
      }

      #initializeFloorGraphButton {
        height: 10% ; 
        width: 25% ; 
        background-color: khaki ;  
        align-self: left ; 
        float: left ; 
      }

      #randomButton {
        height: 10% ; 
        width: 25% ; 
        background-color: silver ;  
        align-self: left ; 
        float: left ; 
      }

    </style>



  </head>
  <body>

    <div id = header>hello</div>

    <div id="map"></div>

    <div id = "palette">
      <div id = "saveButton">Save</div>
      <div id = "loadButton"> <input type = "file" /></div>
      <div id = "newMapItem">New item</div>
      <div id = "removeHallButton">Remove hall</div>
      <div id = "initializeFloorGraphButton">Set up graph</div>
      <div id ="randomButton"> Dijkstra's Algorithm </div>


    </div>

    

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD0ttZsTPTea51DS9o-q6RR6yi1sBmZH70&callback=initMap"></script>
    <script src = "CustomOverlay.js" type = "text/javascript"></script>
    <script src = "hallNode.js" type = "text/javascript"></script>
    <script src = "FileSaver.js" type = "text/javascript"></script>
      
    <script>


      var hallwayArray = new Map() ; 
      var hIndex = 1 ; 

      var map;
      var palette = document.getElementById("palette") ;
      var header = document.getElementById("header") ;
      var marker ; 
      
      var network = new Map(); 
      var nIndex = 0 ; 

      var networkArray = [] ; 

      var currentHallway = -1 ; 

      var mapListenerTag, order = 1, start, end ; 
      var graphNotReady = true ; 

      /*
      This initializes the map and also creates the functionality of the buttons of this application.
      */

      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 62.323907, lng: -150.109291},
          zoom: 18
        });
       
        center = new google.maps.LatLng(62.323907, -150.109291) ; 
        
       // initializeHallway(center, [20,20,0], map, hIndex) ;
        initializeHallway(center, [20,20,0], map, hIndex) ;

        newMapItem.onclick = function() {
          initializeHallway(center, [20,20,0], map, hIndex) ;
        } ;
        
        saveButton.onclick = function() {
          saveMap() ; 
        }

        loadButton.onclick = function() {
          initializeFloorGraph() ; 
        }

        loadButtonInput = document.querySelector('input[type="file"]') ;

        loadButtonInput.addEventListener('change', function(e) {
          const reader = new FileReader() ; 
          reader.onload = function() {
           // console.log(reader.result) ;
            lines = reader.result.split('\n') ; 
            loadMap(lines) ; 
          }
          reader.readAsText(loadButtonInput.files[0]) ; 
      }, false) ; 

        removeHallButton.onclick = function() {
          removeHall(currentHallway) ; 
        }

        initializeFloorGraphButton.onclick = function() {
          initializeFloorGraph() ; 
        }

        //62.324182634744965 , longitude: -150.1088704298229
        //Latitude: 62.32440936968727 , longitude: -150.10814623338888
        // 62.324456709734065 , longitude: -150.10876850588033

        u = new google.maps.LatLng(62.324182634744965 , -150.1088704298229) ; 
        l = new google.maps.LatLng(62.32440936968727 ,-150.10814623338888) ; 
        o = new google.maps.LatLng(62.324456709734065 ,-150.10876850588033) ; 

        pathway = [u,l,o] ; 

        //getPointToLine(o, u ,l) ; 

        var t = true ; 

        randomButton.onclick = function() {
          if (t) {
            mapListenerTag = google.maps.event.addListener(map, 'click', function(event) {
            if (order == 1) {
              start = new google.maps.LatLng(event.latLng.lat(), event.latLng.lng()) ; 
              order = 2 ; 

            } else if (order == 2) {
              end = new google.maps.LatLng(event.latLng.lat(), event.latLng.lng()) ; 
              order = 1 ; 
              dijkstrasAlgorithm(start, end) ; 

              start = null ; 
              end = null ; 

              google.maps.event.removeListener(mapListenerTag) ; 
              order = 1 ; 
        }
      });
            
          } else {
            google.maps.event.removeListener(mapListenerTag) ;
            t = true ; 
          }
        }
         alert("To use this app: First load the newMap file or build your own") ;
         alert("Press on the \"set up graph\" button when done or loaded") ;
         alert("Then press on the \"dijstras algorithm button\" and click anywhere on the building twice") ; 
      }

      /*
      This takes an array of strings as a parameter and loads the map from a file saved from this application. 
      */
      function loadMap(lines) {
        console.log("loading new map") ;
        //lat , lng, vetical, horizontal, bearing
        var lat, lng, vertical, horizontal, bearing, center ; 
        
        for (const i of hallwayArray.keys()) {
          removeHall(i) ; 
        }

        hIndex = 1 ; 
        

        hallwayArray = new Map() ; 
        

        for (i = 0; i < lines.length - 1; i++) {
          line = lines[i].split(',') ;
          
          lat = parseFloat(line[0]) ; 
          lng = parseFloat(line[1]) ; 
          vertical = parseFloat(line[2]) ; 
          horizontal = parseFloat(line[3]) ; 
          bearing = parseFloat(line[4]) ; 

          center = new google.maps.LatLng(lat, lng) ; 

          initializeHallway(center, [vertical, horizontal, bearing], map, hIndex) ;
        }

        for (const i of hallwayArray.keys()) {
          hallwayArray.get(i).hideMarkers() ; 

        }



      }


      /*
      This is used to choose which hallway will be removed if the user presses the "remove hallway button.
      It is also used to make bulding floor plans more aestheticly pleasing. 
      "
      */
      function setActiveHallway(hall) {
        currentHallway = hall ; 

        hallwayArray.get(currentHallway).showMarkers() ; 
        

        for (const i of hallwayArray.keys()) {
          if (i != hall) {
            hallwayArray.get(i).hideMarkers() ; 
            //hallwayArray.get(i).changeColor("blue.jpg") ;
          }
        }
      }

      /*
      This function is used to remove a hall if the user decides to do so. 
      It takes the hall's hIndex as a parameter. 
      */
      function removeHall(hall) {
        hallwayArray.get(hall).setMap(null) ; 
        hallwayArray.get(hall).rotationMarker.setMap(null) ; 
        hallwayArray.get(hall).rightMarker.setMap(null) ; 
        hallwayArray.get(hall).bottomMarker.setMap(null) ;
        hallwayArray.get(hall).centerMarker.setMap(null) ;
        hallwayArray.delete(hall) ;
      }


      /*
      This saves the map into a text file for later use. 
      */
      function saveMap() {
        var lines = [] ; 
        var hall, bearing, vertical, horizontal, center ;
        var line ; 
        
        for (const i of hallwayArray.keys()) {
          vertical = hallwayArray.get(i).dimensions[0] ; 
          horizontal = hallwayArray.get(i).dimensions[1] ; 
          bearing = hallwayArray.get(i).bearing ; 
          center = hallwayArray.get(i).center ; 

          //lat, lng, vertical, horizontal, bearing

          vertical = vertical.toString() ;

          if (vertical != "NaN") {
          horizontal = horizontal.toString() ;
          bearing = bearing.toString()
          lat = center.lat().toString() ; 
          lng = center.lng().toString() ; 

          line = lat + "," + lng + "," + vertical + "," + horizontal + "," + bearing + "\n" ; 

          lines.push(line) ; 
          }
        }

        var blob = new Blob(lines, {type: "text/plain"}) ;
        var name ; 

        saveAs(blob,"newMap.txt")


      }

      /*
      This function implements the haversine equation to calculate the distances between points. 
      It is the only function here that was not written by me. 

      Here is where I found it and yes of course it was stack overflow. 
      https://stackoverflow.com/questions/1502590/calculate-distance-between-two-points-in-google-maps-v3
      
      */
      function getDistance(lower, upper) {
      EARTH_RADIUS = 6378.137 ; //Units are KM
      var dLat, dLon, a, c,d ;

      dLat = toRad(upper.lat()) - toRad(lower.lat()) ;
      dLon = toRad(upper.lng() - lower.lng()) ;

      a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lower.lat() * Math.PI / 180) * Math.cos(upper.lat() * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);

      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      d = EARTH_RADIUS * c ;


      return d * 1000 ;
  }


    /*
    This function takes four LatLngs as parameters. Each pair is meant to represent a straight line. 
    This line finds a point of intersection between these two lines. 
    It returns the location of that point. 

    */
      function findPOI(start1, end1, start2, end2) {
        rise1 = end1.lat() - start1.lat() ; 
        run1 = end1.lng() - start1.lng() ; 

        slope1 = rise1/run1 ; 
        b1 = end1.lat() - slope1*end1.lng() ; 

        rise2 = end2.lat() - start2.lat() ; 
        run2 = end2.lng() - start2.lng() ; 

        slope2 = rise2/run2 ; 
        b2 = end2.lat() - slope2*end2.lng() ;

        x = (b2-b1)/(slope1-slope2) ; 
        y = slope1*x + b1 ; 

        intersection = new google.maps.LatLng(y,x) ; 

        if (checkIfPointInBounds(start1, end1, start2, end2, intersection)) {
          return intersection ;
        } else {
          return false ; 
        }
      }
      /*
      The findPOI function finds a point of intersection but does not check whether it is within the bounds of the two 
      potentially overlapping hallways. 

      Thus, checkIfPointInBounds checks if the point is in between each of the four points. 

      Parameters: It takes the four points and the point found by findPOI. 

      It returns true or false based on whether the POI is in between the four points. 

      */

      function checkIfPointInBounds(start1, end1, start2, end2, intersection) {
        ItoS1x = start1.lng() - intersection.lng() ; 
        ItoS1y = start1.lat() - intersection.lat() ; 

        ItoE1x = end1.lng() - intersection.lng() ; 
        ItoE1y = end1.lat() - intersection.lat() ;

        if (ItoS1x*ItoE1x + ItoS1y*ItoE1y > 0) {
          return false ; 
        }

        ItoS2x = start2.lng() - intersection.lng() ; 
        ItoS2y = start2.lat() - intersection.lat() ; 

        ItoE2x = end2.lng() - intersection.lng() ; 
        ItoE2y = end2.lat() - intersection.lat() ;

        if (ItoS2x*ItoE2x + ItoS2y*ItoE2y > 0) {
         // console.log("false") ;
          return false ; 
        }
        
      //  console.log("true") ;
        return true ; 
      }


      /*
      This function takes two halls as parameters. 

      It then determines whether they are intersecting and finds the points at which they do. 

      It returns an array of length 0 or up to 16 depending on the number of possible intersections (16 is impossible however but theoretical). 
      */
      function checkHallOverlap(moving, stationary) {
        intersections = [] ; 
        temp = findPOI(moving.lowerRight, moving.upperRight, stationary.lowerRight, stationary.upperRight) ;
        if (temp != false) {
          intersections[0] = temp ; 
        } 

        temp = findPOI(moving.lowerRight, moving.upperRight, stationary.lowerLeft, stationary.upperLeft) ;
        if (temp != false) {
          intersections[1] = temp ; 
          
        } 

        temp = findPOI(moving.lowerRight, moving.upperRight, stationary.lowerLeft, stationary.lowerRight) ;
        if (temp != false) {
          intersections[2] = temp ; 
        } 

        temp = findPOI(moving.lowerRight, moving.upperRight, stationary.upperLeft, stationary.upperRight) ;
        if (temp != false) {
          intersections[3] = temp ; 
        } 


        temp = findPOI(moving.lowerLeft, moving.upperLeft, stationary.lowerRight, stationary.upperRight) ;
        if (temp != false) {
          intersections[4] = temp ; 
        } 

        temp = findPOI(moving.lowerLeft, moving.upperLeft, stationary.lowerLeft, stationary.upperLeft) ;
        if (temp != false) {
          intersections[5] = temp ; 
        } 

        temp = findPOI(moving.lowerLeft, moving.upperLeft, stationary.lowerLeft, stationary.lowerRight) ;
        if (temp != false) {
          intersections[6] = temp ; 
        }

        temp = findPOI(moving.lowerLeft, moving.upperLeft, stationary.upperLeft, stationary.upperRight) ;
        if (temp != false) {
          intersections[7] = temp ; 
        } 


        temp = findPOI(moving.lowerLeft, moving.lowerRight, stationary.lowerRight, stationary.upperRight) ;
        if (temp != false) {
          intersections[8] = temp ; 
        } 

        temp = findPOI(moving.lowerLeft, moving.lowerRight, stationary.lowerLeft, stationary.upperLeft) ;
        if (temp != false) {
          intersections[9] = temp ; 
        } 

        temp = findPOI(moving.lowerLeft, moving.lowerRight, stationary.lowerRight, stationary.lowerLeft) ;
        if (temp != false) {
          intersections[10] = temp ; 
        } 

        temp = findPOI(moving.lowerLeft, moving.lowerRight, stationary.upperRight, stationary.upperLeft) ;
        if (temp != false) {
          intersections[11] = temp ; 
        } 


        temp = findPOI(moving.upperLeft, moving.upperRight, stationary.lowerRight, stationary.upperRight) ;
        if (temp != false) {
          intersections[12] = temp ; 
        } 

        temp = findPOI(moving.upperLeft, moving.upperRight, stationary.lowerLeft, stationary.upperLeft) ;
        if (temp != false) {
          intersections[13] = temp ; 
        } 

        temp = findPOI(moving.upperLeft, moving.upperRight, stationary.lowerRight, stationary.lowerLeft) ;
        if (temp != false) {
          intersections[14] = temp ; 
        } 

        temp = findPOI(moving.upperLeft, moving.upperRight, stationary.upperRight, stationary.upperLeft) ;
        if (temp != false) {
          intersections[15] = temp ; 
        } 
       // console.log(intersections.length > 0) ;

        return intersections ; 
      }


      /*
      This function determines whether a point is above or below a straight line. 

      Parameters: it takes 2 points that represent the straight line. 
      It also takes the point that is being tested for whether it is above or below the line. 

      It returns true if the point is above the line and false if it is below or on the line. 
      */

      function getPointToLine(location, point1, point2) {
        rise = point2.lat() - point1.lat() ; 
        run = point2.lng() - point1.lng() ; 

        slope = rise/run ; 
        b = point1.lat() - slope*point1.lng() ;
        
        newPointLat = location.lng()*slope + b ;
        
        if (location.lat() > newPointLat) {
          return true ; 
        } else {
          return false ; 
        }
      }

      /*
      This function determines whether a point is inside a hallway.

      Parameters: it takes the location to be tested and the hIndex of the hallway to be tested. 

      It returns true if the point is in the hall or false if it is not. 
      
      */
      function checkIfPointInHall3(location, hall) {

        ULtoUR = getPointToLine(location, hallwayArray.get(hall).upperLeft, hallwayArray.get(hall).upperRight) ; 
        URtoLR = getPointToLine(location, hallwayArray.get(hall).upperRight, hallwayArray.get(hall).lowerRight) ;
        LRtoLL = getPointToLine(location, hallwayArray.get(hall).lowerRight, hallwayArray.get(hall).lowerLeft) ;
        LLtoUL = getPointToLine(location, hallwayArray.get(hall).lowerLeft, hallwayArray.get(hall).upperLeft) ;

        if (hallwayArray.get(hall).bearing == 0) {
          return LRtoLL && !ULtoUR && location.lng() < hallwayArray.get(hall).upperRight.lng() && location.lng() > hallwayArray.get(hall).upperLeft.lng() ; 

        } else if (hallwayArray.get(hall).bearing == 90) {
          return URtoLR && !LLtoUL && location.lng() < hallwayArray.get(hall).upperLeft.lng() && location.lng() > hallwayArray.get(hall).lowerLeft.lng() ;  ;

        } else if (hallwayArray.get(hall).bearing == 180) {
          return ULtoUR && !LRtoLL && location.lng() < hallwayArray.get(hall).upperLeft.lng() && location.lng() > hallwayArray.get(hall).lowerRight.lng() ;  ;  ;

        } else if (hallwayArray.get(hall).bearing == 270) {
          return !URtoLR && LLtoUL && location.lng() < hallwayArray.get(hall).lowerLeft.lng() && location.lng() > hallwayArray.get(hall).upperLeft.lng() ;  ; ;
        }

        if (hallwayArray.get(hall).bearing < 90) {
          return !ULtoUR && URtoLR && LRtoLL && !LLtoUL ; 

        } else if (hallwayArray.get(hall).bearing < 180) {
          return ULtoUR && URtoLR && !LRtoLL && !LLtoUL ;

        } else if (hallwayArray.get(hall).bearing < 270) {
          return ULtoUR && !URtoLR && !LRtoLL && LLtoUL ;

        } else {
          return !ULtoUR && !URtoLR && LRtoLL && LLtoUL ;
        }

      }
    
      /*
      This function finds which hall a point is in or determines that it is not in any hall. 

      Parameters: it takes one parameter which is the location to be tested. 

      It returns the hIndex of the hall if the point is found or false if it is not. 
      
      */
      function locatePoint(location) {
        
        for (const i of hallwayArray.keys()) {
          if (checkIfPointInHall3(location, i)) {
           // console.log(i) ;  
            return i ; 
          }
        }
       // console.log(false) ;
        return false ; 

      }

      /*

      This function gets the start and end points to use dijkstras Algorithm from the user.  
      
      */
      function getstartAndEnd(event) {
      
        if (order == 1) {
          start = new google.maps.LatLng(event.LatLng.lat(), event.LatLng.lng()) ; 
          order = 2 ; 
        } else if (order == 2) {
          end = new google.maps.LatLng(event.LatLng.lat(), event.LatLng.lng()) ; 
          order = 1 ; 
          dijkstrasAlgorithm(start, end) ; 

          start = null ; 
          end = null ; 

          google.maps.event.removeListener(mapListenerTag) ; 

        }

      }


      /*
      This function uses dijkstras algorithm to draw the path between two points in the builindg. It 
      is the cherry on top of the application so far. 
      
      Parameters: the start and end locations of the potential path. 

      It returns null if the points are not in the building. If successful, it returns nothing. 
      
      */
      function dijkstrasAlgorithm(start, end) {
        console.log("DRAW PATH") ;
        
        m = new google.maps.Marker({
          map: map, 
          position: start
        }) ;

        m = new google.maps.Marker({
          map: map, 
          position: end
        }) ;
        
        startHall = locatePoint(start) ; 
        endHall = locatePoint(end) ;

        console.log(startHall) ; 
        console.log(endHall) ; 

       // alert( "Latitude: "+ start.lat()+" "+", longitude: "+ start.lng() ); 
       // alert( "Latitude: "+ end.lat()+" "+", longitude: "+end.lng() ); 
        
       //Checks if the points are within the building. 
        if (startHall == false) {
          alert("Start is not in building") ; 
          return null ; 
        }

        if (endHall == false) {
          alert("End is not in building") ; 
          return null ; 
        }

        if (graphNotReady) {
          alert("Please hit set up graph") ;
          return null ; 
        }

        startHallNode = hallwayArray.get(startHall).centerNode ; 
        endHallNode = hallwayArray.get(endHall).centerNode ;

        //Adds start node to the network
        network.set(nIndex, new HallNode(start, [startHallNode], nIndex)) ; 
        network.get(startHallNode).addConnection(nIndex) ; 
        startNode = nIndex ; 
        nIndex++ ;  

        //Adds end node to the network 
        network.set(nIndex,  new HallNode(end, [endHallNode], nIndex)) ; 
        network.get(endHallNode).addConnection(nIndex) ; 
        endNode = nIndex ; 
        nIndex++ ; 
        
         

        console.log(startNode) ;
        console.log(endNode) ; 
        
        var visitied = [] ; 
        var univisited = Array.from(network.keys()) ; 
        var previous = new Map() ; 
        var shortestDist = new Map() ; 
        var distance, totalDistance ; 
        var MAX = 9999999999 ;  
        var max = MAX ; 
        var currentNode, cnPosition, currentConnections ; 
        var x,y,z = 0 ; 

        univisited = [] ; 

        for (const i of network.keys()) {
          univisited.push(i) ; 
        }

        for (const i of univisited) {
          shortestDist.set(i, max) ;  
          
        }
        
        shortestDist.set(startNode, 0) ;
        //console.log(shortestDist.get(startNode) + " " + startNode) ;
        x = 0 ; 
        while (univisited.length != 0 && x < 90) {
         printArray(univisited) ; 
         console.log("x") ; 
         
          for (y = 0; y < univisited.length; y++) {
            if (shortestDist.get(univisited[y]) < max) {
              console.log("in " + univisited[y] + " " + y) ;
              currentNode = univisited[y] ; 
              cnPosition = y ; 
              max = shortestDist.get(univisited[y]) ; 
            }
          }

          console.log(currentNode) ;

         currentConnections = network.get(currentNode).connections ; 

          for (z = 0; z < currentConnections.length; z++) {

           //console.log(currentNode + ":" + i) ; 
           // console.log(i) ; 
            distance = getDistance(network.get(currentNode).position, network.get(currentConnections[z]).position) ;
            totalDistance = distance + shortestDist.get(currentNode) ; 

            if (i in univisited && totalDistance < shortestDist.get(currentConnections[z])) {
              console.log(currentNode + ":" + currentConnections[z]) ; 
              previous.set(currentConnections[z], currentNode) ; 
              shortestDist.set(currentConnections[z], totalDistance) ;
            }
            console.log("a") ;

          }

          visitied.push(currentNode) ; 
          console.log("Before") ;
        
          console.log(cnPosition) ;
          if (cnPosition == 0) {
            univisited.shift() ; 
          } else if (cnPosition == univisited.length - 1) {
            univisited.pop() ; 
          } else {
            univisited.splice(cnPosition, 1) ; 
          }
          
          console.log("after")
        
          max = MAX ; 
        
        }

        var viewedHall = endNode ; 
        var pathway = [network.get(endNode).position] ;

        x = 0 ; 
        while (viewedHall != startNode && x < 90) {
          viewedHall = previous.get(viewedHall) ; 
          pathway.push(network.get(viewedHall).position) ;
          x++ ; 
        }

        var route = new google.maps.Polyline({
          path: pathway,
          geodesic: true,
          strokeColor: '#FF0000',
          strokeOpacity: 1.0,
          strokeWeight: 2,
          visible: true,
          width: 100,
          color: 'red',
          map: map  
  }) ;
 } // end of function 

      /*
      This function creates a connecting node between two halls. 

      Parameters: it takes the intersections array from checkHallOverlap as well as the hIndexes of the two halls. 

      It returns nothing. 
      
      */
      function IFGcreateNewNode(intersections, hall1, hall2) {
        var aLat = 0, aLng = 0, counter = 0 ; 
        hall1 = hallwayArray.get(hall1).centerNode ; 
        hall2 = hallwayArray.get(hall2).centerNode ; 
        

        for (z = 0; z < intersections.length; z++) {
          if (intersections[z] != null || NaN) {
            aLat += intersections[z].lat() ; 
            aLng += intersections[z].lng() ;
            counter++ ;  
          }
        }

        midPoint = new google.maps.LatLng(aLat/counter, aLng/counter) ; 
        

        newNode = new HallNode(midPoint, [hall1, hall2], nIndex) ; 

        network.set(nIndex, newNode) ;
        console.log(nIndex) ;
        network.get(hall1).addConnection(nIndex) ;
        network.get(hall2).addConnection(nIndex) ;

        nIndex++ ; 
        
         
       
        console.log("here") ;
        console.log(midPoint.lat()) ;
        console.log(midPoint.lng()) ;
        m = new google.maps.Marker({
          map: map, 
          position: midPoint
        }) ;
        
      }

      /*
      This analyzes the floor plan and creates a nodal graph based off of it (pretty cool huh? maybe you should hire the person who made this?) 17jal21@queensu.ca :)
      It checks for every possible intersection (which is somehow still O(n^2) despite being a brutal computation). It then 
      creates nodes based off of those intersections. 
      
      Parameters: none. It does rely on the network, hallwayArray, hIndex and nIndex as globals however. 

      It returns nothing.       
      */
      function initializeFloorGraph() {
        var halls = Array.from(hallwayArray.keys()) ; 
        console.log(halls) ; 
        console.log(halls.length) ;
        var x,y ; 
      
        network = new Map() ;
        nIndex = 0 ; 

        
        for (const i of hallwayArray.keys()) {
          newNode = new HallNode(hallwayArray.get(i).center, [], nIndex, i) ;
          hallwayArray.get(i).centerNode = nIndex ;  
          network.set(nIndex, newNode) ; 
          console.log(nIndex) ;

          nIndex++ ;
        }
        
        console.log("connections") ; 
        for (x = 0; x < halls.length; x++) {
          for (y = x + 1; y < halls.length; y++) {
            
            intersections = checkHallOverlap(hallwayArray.get(halls[x]), hallwayArray.get(halls[y])) ; 

            if (intersections.length > 0) {
              IFGcreateNewNode(intersections, halls[x], halls[y]) ; 
            }
          }
        }

        console.log("check up") ; 

        for (const i of network.keys()) {
          console.log(i) ; 
          console.log(network.get(i).position.lat()) ; 
          console.log(network.get(i).position.lng()) ;
          console.log(network.get(i).connections) ;
        }



        console.log("done")
        graphNotReady = false ; 
      }

      /*
      This function creates and manages new hallways that the user wants to add. 

      Parameters: 
        -The first is the center of the hallway and where it will be spawned in. 
        -The second is the "dimensions" array. This contains its length, width and the angle of it. Google maps did not really make it clear on how to rotate them and it took me a suprising amount of work. 
        -It takes the map that it is meant to be on. 
        -It also takes its hIndex becasue even tho it is a global variable, a new instance must be made for each function call. 
      */
      function initializeHallway(center, dimensions, map, hallIndex) {

        hallwayArray.set(hallIndex, new CustomOverlay(center, dimensions, map)) ;

        hallwayArray.get(hallIndex).centerMarker.addListener('click', function() {
          setActiveHallway(hallIndex) ; 
        }) ;
        
        hallwayArray.get(hallIndex).centerMarker.addListener('drag', function() {
          hallwayArray.get(hallIndex).updateCenter(hallwayArray.get(hallIndex).centerMarker.getPosition()) ;
          setActiveHallway(hallIndex) ; 
        }) ;

        hallwayArray.get(hallIndex).centerMarker.addListener('dragend', function() {
          hallwayArray.get(hallIndex).updateCenter(hallwayArray.get(hallIndex).centerMarker.getPosition()) ;
          //removeHallConnections(hallIndex) ; 
         // handleTransformation(hallIndex) ;
        }) ;

        hallwayArray.get(hallIndex).rotationMarker.addListener('drag', function() {
          hallwayArray.get(hallIndex).rotate() ;
        }) ;

        hallwayArray.get(hallIndex).rotationMarker.addListener('dragend', function() {
          rotationLatLng = hallwayArray.get(hallIndex).getOverlayBoundaries(hallwayArray.get(hallIndex).center, hallwayArray.get(hallIndex).dimensions[0]/2, hallwayArray.get(hallIndex).bearing) ;
          hallwayArray.get(hallIndex).rotationMarker.setPosition(rotationLatLng) ;
        }) ;

        hallwayArray.get(hallIndex).rightMarker.addListener('drag', function() {
          hallwayArray.get(hallIndex).adjustRight() ; 
        }) ;

        hallwayArray.get(hallIndex).rightMarker.addListener('dragend', function() {
          hallwayArray.get(hallIndex).rightMarker.setPosition(hallwayArray.get(hallIndex).right) ; 
        }) ;

        hallwayArray.get(hallIndex).bottomMarker.addListener('drag', function() {
          hallwayArray.get(hallIndex).adjustBottom() ; 

        }) ;

        hallwayArray.get(hallIndex).bottomMarker.addListener('dragend', function() {
          hallwayArray.get(hallIndex).bottomMarker.setPosition(hallwayArray.get(hallIndex).bottom) ; 
        }) ;

        hIndex++; 
      }

      function printArray(a) {
         
        for (i in a) {
         
        }
        
         
      }

      google.maps.event.addDomListener(window, 'load', initMap);

    </script>
   
    
 <!--   <script src = "DebugOverlay.js" type = "text/javascript"></script> --> 

  </body>
</html>

<!--  AIzaSyD0ttZsTPTea51DS9o-q6RR6yi1sBmZH70 -->
<!--http://jsfiddle.net/adelriosantiago/3tzzwmsx/4/-->
<!--
SCRAP CODE 

function pointInRectangle(m, r) {
        var AB = vector(r.A, r.B);
        var AM = vector(r.A, m);
        var BC = vector(r.B, r.C);
        var BM = vector(r.B, m);
        var dotABAM = dot(AB, AM);
        var dotABAB = dot(AB, AB);
        var dotBCBM = dot(BC, BM);
        var dotBCBC = dot(BC, BC);
        return 0 <= dotABAM && dotABAM <= dotABAB && 0 <= dotBCBM && dotBCBM <= dotBCBC;
      }

      function vector(p1, p2) {
        latMid = (p2.lat() + p1.lat())/2 ; 
        m_per_deg_lat = 111132.954 - 559.822 * Math.cos( 2 * latMid ) + 1.175 * Math.cos( 4 * latMid);
        m_per_deg_lon = 111132.954 * Math.cos ( latMid );

        a = Math.abs((p2.lng() - p1.lng())*m_per_deg_lon) ;
        b = Math.abs((p2.lat() - p1.lat())*m_per_deg_lat) ; 

          return {
            x: (a),
            y: b
          };
      }

      function dot(u, v) {
        return u.x * v.x + u.y * v.y; 
      }

      function handleTransformation(index) {

        for (const i of hallwayArray.keys()) {
          if (index != i) {
            intersections = checkHallOverlap(hallwayArray.get(index), hallwayArray.get(i)) ; 
            
           if (intersections.length > 0) {
             handleNewInteresction(index, i, intersections) ;
              
           }
          }
        }
      }

      function handleNewInteresctionT1(moved, stationary, intersections) {
        var aLat = 0, aLng = 0, counter = 0 ; 
        

        for (z = 0; z < intersections.length; z++) {
          if (intersections[z] != null) {
            aLat += intersections[z].lat() ; 
            aLng += intersections[z].lng() ;
            counter++ ;  
          }
        }

        midPoint = new google.maps.LatLng(aLat/counter, aLng/counter) ; 

        newNode = new HallNode(midPoint, [], nIndex) ; 
        
        network.set(nIndex, newNode) ;

        connectNodes(nIndex, hallwayArray.get(moved).connectedHalls.centerNode.index) ;
        connectNodes(nIndex, hallwayArray.get(stationary).connectedHalls.centerNode.index) ;

        hallwayArray.get(moved).connectedHalls.addHall(stationary, [nIndex]) ;
        hallwayArray.get(stationary).connectedHalls.addHall(moved, [nIndex]) ;  

        for (p = 0; p < hallwayArray.get(moved).connectedHalls.halls.length ; p++) {
            console.log("connected hall "+hallwayArray.get(moved).connectedHalls.halls[p]) ;

            for (q = 0; q < hallwayArray.get(moved).connectedHalls.nodeSets[p].length ; q++) {
            console.log("nodes: "+hallwayArray.get(moved).connectedHalls.nodeSets[p][q]) ;

          } 

        } 

        for (p = 0; p < hallwayArray.get(stationary).connectedHalls.halls.length ; p++) {
            console.log("connected hall "+hallwayArray.get(stationary).connectedHalls.halls[p]) ;

            for (q = 0; q < hallwayArray.get(stationary).connectedHalls.nodeSets[p].length ; q++) {
            console.log("nodes: " + hallwayArray.get(stationary).connectedHalls.nodeSets[p][q]) ;

          } 

        } 

        nIndex++ ; 

       
        m = new google.maps.Marker({
          map: map, 
          position: midPoint
        }) ;
        
      }

      function removeHallConnections(index) {
        
        for (a = 0; a < hallwayArray.get(index).connectedHalls.halls.length; a++) {
            temp = hallwayArray.get(index).connectedHalls.halls[a] ; 
            b = 0 ; 
    
            while (hallwayArray.get(temp).connectedHalls.halls[b] != index && hallwayArray.get(temp).connectedHalls.halls[b].length > 0) {
                b++ ; 
                console.log("hello") ; // problem is here
            }

            console.log("hi") ;

            //hallwayArray.get(temp).connectedHalls.nodeSets[b]
            console.log() ; 
            for (c = 0; c < hallwayArray.get(temp).connectedHalls.nodeSets[b].length; c++) {
                network.delete(hallwayArray.get(temp).connectedHalls.nodeSets[b][c]) ;
                console.log("sup") ;
            }

            hallwayArray.get(temp).connectedHalls.halls.splice(b,b) ; 
            hallwayArray.get(temp).connectedHalls.nodeSets.splice(b,b) ; 
        }

        hallwayArray.get(index).connectedHalls.cleanConnections() ; 

      }

      function addNodeToNetwork() {

      }

      function checkIfPointInHall2(location, hall) {
       var upperRight, upperLeft, lowerRight, lowerLeft ; 
        
        if (hallwayArray.get(hall).bearing < 90) {
          upperRight = location.lat() < hallwayArray.get(hall).upperRight.lat() && location.lng() < hallwayArray.get(hall).upperRight.lng() ; 
          upperLeft = location.lat() < hallwayArray.get(hall).upperLeft.lat() && location.lng() > hallwayArray.get(hall).upperLeft.lng() ; 
          lowerRight = location.lat() > hallwayArray.get(hall).lowerRight.lat() && location.lng() < hallwayArray.get(hall).lowerRight.lng() ; 
          lowerLeft = location.lat() > hallwayArray.get(hall).lowerLeft.lat() && location.lng() > hallwayArray.get(hall).lowerLeft.lng() ; 

        } else if (hallwayArray.get(hall).bearing < 180) {
          upperRight = location.lat() > hallwayArray.get(hall).upperRight.lat() && location.lng() < hallwayArray.get(hall).upperRight.lng() ; 
          upperLeft = location.lat() < hallwayArray.get(hall).upperLeft.lat() && location.lng() < hallwayArray.get(hall).upperLeft.lng() ; 
          lowerRight = location.lat() > hallwayArray.get(hall).lowerRight.lat() && location.lng() > hallwayArray.get(hall).lowerRight.lng() ; 
          lowerLeft = location.lat() < hallwayArray.get(hall).lowerLeft.lat() && location.lng() > hallwayArray.get(hall).lowerLeft.lng() ; 

        } else if (hallwayArray.get(hall).bearing < 270) {

        } else {}

        if (upperRight && upperLeft && lowerLeft && lowerRight) {
          return hallwayArray.get(hall) ; 
        } 

      }

      function connectNodes(node1, node2) {
          network.get(node1).addConnection(node2) ;
          network.get(node2).addConnection(node1) ;   
      }

      function checkIfPointInHall(location, hall) {
        var A = hallwayArray.get(hall).upperRight ; 
        var B = hallwayArray.get(hall).lowerRight ; 
        var C = hallwayArray.get(hall).upperLeft ; 
        m = location ; 

        var AB = vector(A, B);
        var AM = vector(A, m);
        var BC = vector(B, C);
        var BM = vector(B, m);
        var dotABAM = dot(AB, AM);
        var dotABAB = dot(AB, AB);
        var dotBCBM = dot(BC, BM);
        var dotBCBC = dot(BC, BC);
        return 0 <= dotABAM && dotABAM <= dotABAB && 0 <= dotBCBM && dotBCBM <= dotBCBC;

      }


-->